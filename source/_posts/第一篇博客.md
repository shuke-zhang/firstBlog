---
title: 第一篇博客
date: 2022-11-17 19:59:46
tags:
---
# 	    															JS高级---day1

##  作用域

###  基本概念呢

1. 作用域 Scope： 变量和函数的可访问范围 ===> 作用域控制着变量和函数的可见性 和 生命周期。

###  全局作用域 - Global

1. 直接写在script或者JS代码（单独的JS文件），属于全局作用域
2. **可见性： 全局作用域中声明的变量，在代码的任何地方都可以访问**
3. 生命周期：伴随着页面的生命周期（页面关闭，销毁）

- 直接书写在script标签中，当前是全局作用域

~~~js
const num = 10
        function fn() {
            // 函数内部
            console.log(num)
        }
        fn() // 打印结果为 10
~~~

- 写在**函数内部**，如果**不使用任何关键字声明变量**，那么这个变量会变成**window**的属性


~~~js
function bar() {
            abc = 100
        }
        bar()
        console.log(abc) // 打印结果为 100
~~~



###  局部作用域 - local

1. 在函数内部声明的变量只能在函数内部访问，外部不能访问
2. 可见性：函数外部不能访问函数内部的变量
3. 生命周期：变量在函数调用执行后，就会销毁（清空/回收）

~~~js
 function foo() {
            const abc = 666
            console.log(abc)
        }
        foo()
~~~

###  块级作用域 - block

- 是在ES6发布的新作用域，2015年5月发布
- {}包裹起来的叫代码块，使用**let**或者**const**声明的变量，在`{}`中会产生块级作用域
- **只有let、const会产生块级作用域 {}**
- 块级作用域的外部不能访问内部的变量
- 两个块级作用域中的变量相互不影响
- **if/for是语句**，但是使用let/const 声明的变量，会在内部形成块级作用域
- 对象是没有块级作用域的 ===> 如果我们用{}把对象包裹起来也可以形成块级作用域

~~~js
两个块级作用域中的变量相互不影响，if/for是语句，但是使用let/const 声明的变量，会在内部形成块级作用域
for (let i = 0; i < 3; i++) {
            console.log(i)
        }

for (let i = 0; i < 3; i++) {
            console.log(i)
        }
~~~

###  为什么要新增块级作用域？

- if / for **不是**函数，他们是语句，用**var**声明的变量，**不能**形成作用域；
- var声明的变量，在for循环中，提升到全局

~~~js
var temp = new Date()
        function fn() {
            console.log(temp)
            if (false) {  // if是语句
                var temp = 'hello world'
            }
        }
        fn()
~~~

>如上图代码中，控制输出打印的结果是 undefined，为什么？
>
>由于在函数内部，我们使用了 var 来重新声明了变量，所以它会提升到当前作用域的最前面
>
>同时if是语句，不是函数，var声明变量不能形成作用域
>
>var 声明的变量在提升到前面时只会提升声明，不会提升赋值，所以默认是undefined 
>
>===> 上面代码等同于下面代码

~~~js
 function fn(){
            var temp
            console.log(temp)
            if(false){  // if是语句
                temp = 'hello world'
            }
        }
~~~

>var声明的变量，在for循环中，提升到全局。for循环结束时i等于4 
>
>所以当我们打印下串代码时，寻找的i就是从全局作用域环境中寻找的i，所以结果是 **4**

~~~js
for (var i = 0; i <= 3; i++) {
            console.log(i)
        }
        // 最后循环完，i++， i变为4
        console.log(i)
~~~

###  作用域链

什么是作用域链？

​      函数是可以嵌套函数的，每个函数都有一个局部作用域，这样子，也会形成作用域的嵌套

 当访问内层作用域中的某个变量的时候，首先在当前作用域中查找这个变量，如果不存在，往上层查找，直到全局作用域

- ​     **作用域链的本质：底层变量的查找机制**
- ​      **查找规则：**
- ​      **1. 优先在当前作用域中查找变量**
- ​      **2. 如果不存在，往上层作用域中查找变量，直到全局作用域**

##  let-const-var的区别=>面试题！！！

1. 只有 let / const **可以**形成块级作用域

2. let / const **不存在**变量的提升，但是 var 有

3. let / const **不允许**重复声明，var 可以

4. let / const 存在**暂时性死区**(temporal dead zone)   tdz

5. 浏览器中 ， var 声明的变量在全局作用域中会挂在到window对象上，成为window的属性

   >const和 let 的区别
   >
   >1. const 一旦声明，必须马上赋值，否则会报错
   >
   >       2. const 声明的变量不能改变值 ===> （简单数据不能改变值，引用数据类型不能改变地址）
   >       3. var声明的变量会提升作用域，具体参照**1.5为什么要新增块级作用域？**案列

**第三点解释****var可以同时声明变量，不会报错**===>当打印输出时且是以后声明的那个变量为准

~~~js
function count(){
            var a = 1 
            var a = 2
        }
~~~

**第四点解释 暂时性死亡区**

>用const和let声明变量时都是先声明再使用，如果我们先使用再声明就会存在暂时性死亡区
>
>或者先给变量赋值再用let和const命名，然后我们再打印这个变量，就会报错
>
>注意：如果我们直接将变量注释，此时就是只声明，不赋值。打印结果就是undefined

~~~js
if (true) {
            temp = 'hello world '
            let temp;
    console.log(temp)
        }
~~~

*第五点解释**

>在全局作用域中我们用 var声明变量时，它会变成window的属性，是可以直接打印出来的
>
>但是我们用let声明是，在打印时只会出现 undefined

~~~js
 // ==> 5.解释
         var abc = 666
         console.log(window.abc)
 		let afg = 555
        console.log(window.afg)
        // // ==> 不建议使用var 声明name这个名字， window本身有name这个属性
        // var name = 123
        // console.log(window)
    
~~~



##  垃圾回收机制

###  基本概念 =>面试！！！

>- **什么是垃圾回收机制**
>-  垃圾回收机制(gatbage collection) 简称GC
>-   JS中内存的分配和回收是自动完成的，内存在不使用的时候会被JS引擎/垃圾回收程序自动回收
>
>- **什么是内存泄漏呢?**
>-   内存泄漏: 不再使用的内存,没有及时释放掉(就是没有使用的内存没有回收，就叫做内存泄漏)

###  引用计数法

1. 跟踪记录每个值被引用的次数
2. 如果这个值被引用了一次，那么就记录次数1
3. 多次引用会累加
4. 如果减少一个引用就减少1
5. 如果引用次数是0，则释放内存

注意： ==> 引用计数法并不是周期性的垃圾回收，什么时候引用次数为0了，直接回收

**引用计数法的缺陷** ===> 已被淘汰

>循环引用的时候，堆内存空间中创建的对象相互引用，计数永远不会为 0，所以永远不会清除
>
>  这个对象会一直占用着内存空间，造成内存泄漏

~~~js
 function problem() {
            // oA = new Object()
            let oA = {}
            let oB = {}
            oA.c = oB  //  oB被oA引用
            oB.d = oA  //  oA又被oB引用

            // 你中有我，我中有你  ---- 代涛语录
        }
        problem()
~~~

可查看图解

当相互引用时，引用次数由两次减少一次，但是两个数值之间存在你中有我，我中有你。引用次数就变成 1 ，所以就不会清除这两个对象，就会造成内存泄漏

![image-20221027203851327](assets/image-20221027203851327.png)



###  标记清除计数法

主要将垃圾回收机制的过程分为两个阶段

​    1. **标记阶段**：标记空间中的活动对象和非活动对象

​     2. **清除阶段**：回收非活动对象，也就是销毁非活动对象

>标记阶段从一组根元素开始，
>
>​    递归遍历（一层一层的）这组根元素，
>
>​    在这个遍历过程中，能访问到的元素称为活动对象，不能访问到的可以判断为垃圾数据。

缺陷：**内存碎片化 **===>大白话：当我们把非活动对象进行销毁之后，虽然对象是被销毁了。但是它还在占用着空间，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题。

![image-20221027204551997](assets/image-20221027204551997.png)

PS. **标记整理算法**

标记清除算法的缺点在于清除之后剩余的内存位置不变而导致的空闲内存不连续。

⇒ **标记整理（Mark-Compact）算法**

就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）

![image-20221027204621074](assets/image-20221027204621074.png)



##  闭包 - Closure

###  基本概念

- 定义：**内层函数引用外层函数的变量的集合 **===>闭包 = 内层函数 + 外层函数的变量
- 闭包的条件：首先要有内层函数，内层函数使用了外层函数的变量
- 下串代码是闭包的一个简单写法

~~~js
function outer() {
            const num = 10
            function fn() {
                console.log(num)
            }
            fn()
        }
        outer()
~~~



###  闭包的作用

1. 可以通过闭包.让外部 可以访问到函数内部的变量

~~~js
 function outer() {
            let a = 10
            function fn() {
                console.log(a)

            }
            return fn
        }
        const fun = outer()
        fun()
当我们在外部调用fun的时候，相当于执行下面注释的函数，执行到 log(a),找的是outer 函数内部的变量a
        const fun = function fn(){
            console.log(a)

        }
        相当于 fun 等于 outer这个函数内部的 fn函数
         outer() === fn ===function fn(){console.log(a)}
        
        

~~~

   **闭包的简写**

> 下面代码块中接收的是outer里 return的这个函数，此时只是这个函数，但是并没有调用，所以还需要调用一次
>
>const fn = function(){
>
> 		console.log(a)
>
>}

~~~js
function outer() {
            let a = 10
            return function () {
                console.log(a)

            }
        }
        const fn = outer()
       fn()
~~~



###  闭包的应用案列

需求： 统计一个函数的调用次数

老方法 ===> 此时如果我们修改了全局作用域 i 的数值，那么函数的调用次数也是可以改变的，就不太好

~~~js
 let i = 0 // 全局变量
        function fn(){
            i++
            //   let i = 0  // 局部变量，调用完，i销毁
            console.log(`调用了${i}次`)

        }
        fn()
~~~

**闭包的另一个应用：实现数据的私有化（我们在外面是没法修改这个i变量的）**

​    利用比闭包的方法来统计函数的调用次数，此时可以访问i 这个变量 ，但是不能修改

~~~js
function count() {
            let i = 0
            return function () {
                i++
                console.log(`调用了${i}次`)
            }
        }
const fn = count()
fn()
~~~

>**注意**：记住，当我们用一个变量来接受函数时，只是单纯的用这个函数来接收了 count 内部的这个函数，但是没有执行函数，所以在进行变量接收之后，还需要继续调用一次
>
>const fn = count() ===> 相当等于一下代码
>
>const fn = function(){
>
>​        i++
>
>​        console.log(`调用了${i}次`)
>
>​      }
>
>此时，如果我们在外面修改 i 是修改不了的，因为我们函数调用的 i 是局部作用域里面的，就不能成功修改

###  闭包产生的问题

1. 闭包会产生的问题：内存泄漏

2. 以上面4.3案列举例

   >标记清除法 ： 从一组根元素开始,或者说从全局作用域出发，找到了这个i变量，能访问到这个i变量，把它标记为活动对象,所以根据上述案列
   >
   >在我们调用fn()后，按理说， i是函数count里面的变量，局部变量，执行完后应该销毁
   >
   >但是现在，因为 i 变量和内部的函数function形成了闭包。i被标记成为了活动对象，所以i变量没有被销毁，就会造成内存泄漏

###  闭包的特性和实际应用

   闭包的特性

       1. 通过闭包，我们可以让外部访问导函数内部的变量，同时，实现数据的私有化
       1. 闭包产生的问题，内存泄漏

   闭包的实际应用

       1. 节流 throttle 减少事件执行频率
       2. *防抖 debounce 你先抖动这，什么时候停了，我再执行 让子弹飞一会儿*



##  var变量提升 

- 所有 var 声明的变量会执行之前，会提升到当前作用域的最前面

- ar声明的变量只会提升声明，不提升赋值

- var声明的变量，如果不赋值，默认undefined

- **var a**; ===> j叫做声明， **var b = 6**  ===> 声明并赋值  ==> 叫做初始化

  ~~~js
  // console.log(num + '把剑')  // undefined把剑
         // var num = 10
  举例2 
  function fn() {
              console.log(num)  // undefined
              var num = 20
          }
  fn()
  ~~~

  >控制台打印结果 ===> *undefined*
  >
  >比如在函数，只会提升 var num 但是这个20就不会提升，所以是undefined

     
##  函数的提升

1. **先声明，后调用。**

~~~js
   // 函数的提升

        // 声明式
        fn()
        function fn() {
            console.log(666)
        }

        // 表达式
        const foo = function () {
            console.log(888)
        }

        var bar = function () {
            console.log(999)
        }

        // 1. 会把用function声明的函数，提升到当前作用域的最前面
        // 2. 表达式的情况，如果是用var声明的函数，只提升声明，不提升赋值

        // ===》 建议： 先声明，后调用。'
~~~



## arguments 对象

- 除箭头函数以外，所有的函数都内置了（默认就存在，自带的)一个arguments对象
- arguments 接收了我们传进去的参数，以伪数组的方式存储
- arguments 伪/类数组跟其他伪数组一样， 有length 有索引，没有push等方法
- atguments 对象，只存在于函数中
- 箭头函数没有argunments   
- 小应用===> **不管传入多少参数,函数都会求出总和**

~~~js
 function getSum() {
            let sum = 0
            for (let i = 0; i < arguments.length; i++) {
                sum += arguments[i]
            }
            return sum
        }
        const res = getSum(2, 3, 6, 4, 9)
        console.log(res)
~~~

##  剩余参数rest

- 语法：...变量名 ===> 变量名自定义   
- 是一个真数组，存了剩余的实参
- 只能放在形参的最后一位，否则会报错

~~~js
function getSum(...arr) {
            console.log(arr) // 在使用的时候可以不用写 ...
        }
        function getSum(a, b, ...arr) {
            console.log(arr)

        }
        getSum(2, 6)
        getSum(6, 5, 9, 7, 3)
~~~

>打印结果
>
> 在第一个函数传入 (2, 6)===> [2,6],在第一个函数传入 (2, 6)===>[] 一个空数组，两个实参被a b取了，所以是空数组
>
>在第二个函数传入 (6, 5, 9, 7, 3)===> [6, 5, 9, 7, 3],在第二个函数传入 (2, 6)===>[] 一个空数组，前面两个实参被a b取了，所以是[9, 7, 3]

~~~js
 // 用箭头函数来书写
        const getSum = (...asd) => {
            let sum = 0
            asd.forEach(el => sum += el)
            return sum
        }
        const res = getSum(1, 3, 6, 4)
        console.log(res)

~~~



##  扩展运算符spread

###  基本语法

1. 扩展运算符是三个（...），他好比 rest的逆运算
2. 作用,将一个数组转换成用逗号分隔的参数序列 是数字类型，不会改变**原数组**
3. const arr = [1, 3, 5, 69, 5]===>console.log(...arr) ===>1 3 5 69 5 浏览器不会显示逗号

###  求一个数组的最大值和最小值

Math.max() 她本身接受的是参数列表，所以如果我们用jion 方法来转换时就不可以得到最大值和最小值

- `const arr = [1, 3, 5, 69, 5]`
- `console.log(Math.max(...arr)) `===> 最大值
- `console.log(Math.min(...arr))`===> 最小值

###  复制/拷贝数组 ===> 浅拷贝

- `const a1 = [1, 6]`
- `const a2 = a1`
- `a2[0] = 666`
- `console.log(a1) ===>打印结果 [666,6]`
- 因为我们只是把a1的值赋值给了a2 ，相当于他们在栈中的地址指向堆里面同一个数组
- 所以当改变其中一个的时候，就会同时改变另外一个 ===> 就达不到 复制拷贝的效果

**真正的拷贝数组**

- `const a3 = [6, 4, 9, 3]`

- `const a4 = [...a3]`    

-   ` a3[0] = 5`

-    `console.log(a4) ===>[6,4,9,3]*`

  >由于我们使用了 ... 得到的是一个 6,4,9,3,
  >
  >a4新创建了一个数组，所以地址不一样，当改变a3时，a4并不会改变
  >
  >这就达到了真正的拷贝效果，两个数组之间互不影响。



###  合并数组  (浅拷贝)

~~~js
const a5 = ['c', 'd']
const a6 = ['e', 'f']

        // ES5 的合并 concat
        const resArr = a5.concat(a6)
        console.log(resArr)
        // ES6 ...
        const a7 = [...a5, ...a6]
        console.log(a7)
~~~

**用扩展运算符分别把两个数组转换成参数序列，用一个新数组包括这两个参数序列，就可以得到合并数组**

### 将字符串转化成为一个数组

~~~js
 const str = 'hello world'
        const a8 = [...str]
        // 用split反转字符串
        const res = str.split('').reverse().join('')
        // 用扩展运算符的方式
        const resStr = [...str].reverse().join('')
        console.log(resStr)
~~~

###  将伪数组转为真数组

~~~js
const divs = document.querySelectorAll('div')
        // console.log(divs)
        // divs.push(666)
        const resDiv = [...divs]
        console.log(resDiv)
        resDiv.push(666)
        console.log(resDiv)
~~~

>`const resReal = Array.from(divs)`
>
>​    `console.log(resReal)`
>
>这是另外一个转换为真数组的方式

##  如何区分剩余参数和扩展运算符

>看作用
>
>1. 剩余参数的话 ===> 是通过函数传参的方式来使用的
>2. 扩展运算符的基本使用就是将数组转换成参数序列，语法是 ...数组名















